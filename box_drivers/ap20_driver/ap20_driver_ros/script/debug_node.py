import rospy
from std_msgs.msg import Time
from sensor_msgs.msg import Imu
from geometry_msgs.msg import PointStamped
from std_srvs.srv import SetBool
from collections import deque
from threading import Lock

"""
Node fully generated by Claude - Not tested not working just for debugging. Use cpp version instead.
"""


class AP20Synchronizer:
    def __init__(self):
        rospy.init_node("ap20_synchronizer")

        self.timestamp_queue = deque()
        self.imu_message_queue = deque()
        self.position_message_queue = deque()

        self.imu_queue_lock = Lock()

        self.ap20_imu_pub = rospy.Publisher("/gt_box/ap20/imu", Imu, queue_size=200)
        self.ap20_position_pub = rospy.Publisher("/gt_box/ap20/prism_position", PointStamped, queue_size=100)

        rospy.Subscriber("/ap20/imu", Imu, self.imu_callback)
        rospy.Subscriber("/ap20/tps", PointStamped, self.position_callback)

        self.timestamps_fn = "/sys/kernel/time_stamper/ts_buffer"

    def change_imu_mode(self, enable_streaming):
        rospy.wait_for_service("/ap20/enable_streaming", timeout=5.0)
        try:
            client = rospy.ServiceProxy("/ap20/enable_streaming", SetBool)
            response = client(enable_streaming)
            if response.success:
                rospy.loginfo(
                    f"IMU mode changed successfully. Streaming is now {'enabled' if enable_streaming else 'disabled'}."
                )
                return True
            else:
                rospy.logwarn(f"Failed to change IMU mode: {response.message}")
                return False
        except rospy.ServiceException as e:
            rospy.logerr(f"Failed to call service /ap20/enable_streaming: {e}")
            return False

    def read_timestamps(self):
        timestamps = []
        try:
            with open(self.timestamps_fn, "r") as file:
                for line in file:
                    secs, nsecs = map(int, line.strip().split("."))
                    timestamps.append(rospy.Time(secs, nsecs))
        except IOError:
            rospy.logerr(f"Failed to open timestamps file: {self.timestamps_fn}")
        return timestamps

    def imu_callback(self, msg):
        with self.imu_queue_lock:
            self.imu_message_queue.appendleft(msg)

    def position_callback(self, msg):
        self.position_message_queue.appendleft(msg)

    def run(self):
        rate = rospy.Rate(500)

        self.change_imu_mode(False)
        rospy.sleep(1.0)

        _ = self.read_timestamps()

        rospy.sleep(3.0)
        self.change_imu_mode(True)

        while not rospy.is_shutdown():
            for ts in self.read_timestamps():
                self.timestamp_queue.appendleft(Time(data=ts))

            if self.position_message_queue:
                position = self.position_message_queue.pop()

                closest_time = None
                min_diff = float("inf")

                with self.imu_queue_lock:
                    for imu in self.imu_message_queue:
                        time_diff = abs((imu.header.stamp - position.header.stamp).to_sec())
                        if time_diff < min_diff:
                            min_diff = time_diff
                            closest_time = imu.header.stamp

                print("IMU Time", closest_time)
                position.header.stamp = closest_time
                self.ap20_position_pub.publish(position)

            while self.timestamp_queue and self.imu_message_queue:
                time = self.timestamp_queue.pop()
                with self.imu_queue_lock:
                    imu = self.imu_message_queue.pop()

                imu.header.stamp = time.data
                self.ap20_imu_pub.publish(imu)

            rate.sleep()

        self.change_imu_mode(False)


if __name__ == "__main__":
    try:
        synchronizer = AP20Synchronizer()
        synchronizer.run()
    except rospy.ROSInterruptException:
        pass
